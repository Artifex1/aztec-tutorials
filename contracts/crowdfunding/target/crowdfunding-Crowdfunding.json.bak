{"noir_version":"1.0.0-beta.1+4144a8dce4789d85","name":"Crowdfunding","functions":[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"log_plaintext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8861757336002045335":{"error_kind":"fmtstring","length":99,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"9862881900111276825":{"error_kind":"fmtstring","length":35,"item_types":[{"kind":"field"}]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["process_log"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14313802839798733697":{"error_kind":"string","string":"Function _publish_donation_receipts can only be called internally"},"16541607464495309456":{"error_kind":"fmtstring","length":16,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+VdTW8kRxmu9nhsz9izM7Hj/coXQlEkOKD5tMc3R7sriIQABaGcZz3tYLTxLl4nYgEpFhISEjeQcuTAkTsX/kEkbiBxIAKJX4AEHHJje9PvzONnni737FQ5hpRkdbvrrfe73nqruqoncdOS5Ndl+t8JmP382l6sdALiaktGfcVg+pXPrrX8/yWorwQUtkZ0Q+Iftvs7NSFfQP57tRxnTP0Yzgj426s5nntnU/wsS1Ya+f/oQ9Zm7enfhpveN/P7GrWJYduIum9vCf6XQLas3Dmb6mNRur37e6ODUbttuO+eRZGrt57bqb503k5LLpws/Xa60x7v7iH/WaleoNPs/+VI9jT8K3Hw90yuKuixImQy+g2h96Tgari4zmjVXdw45JMN+bf7FsGzDopwVefEVRN1MWy67JEb6V+WD6O8zoUfbyL1kb7hX42Dv2v41+LoZ6L/Whz+O1V3Pl6+kV8ze7yZC2NxY91Ni8lp/G1Esl/ZuGT068RrrLi0QfywfqyvZnDb+f3og/e+/ejg4Ti9M3rwYDw6Hd15+OgJCoGIlZCoBIThgM5J6N0zDcdJXtPNGnO9gD+jz884iGJ7g2uIdvMMRIqO4tnnuM9LB+XhQeEa1AV0ukOTo+lmi9W1gDbr+QU3q5tE4KrQ/yhTFuBaS1O8DMf8NKAOeWM5KgSflSWCbwn4JsCYHZpu1g7WtibahbNRp90QvLJO0A5so02om9dGJtMiNkLeinTus9ELAh7tzjZqCto10S6gjToNwSvrBO3ANtqCunltZDItYiPkrSgWz9uPMG6yjdYF/xXBF8dEhbshZIsVl9eITiMAHfbNrOzn1/aCpeWKY6by2UVl2AwuQ2+35WbjiNHZAHkmSdCb4/FJ+vhxQnJtCv5VyXC+zji/np7eeXh8ejI6OH3r+PHp6PggvZs+evDwSXrCuc8W/f8i6cpRPV4v4rVKOH+QX7Ok+t383uyK9mK/rUNdC3C858FR9eDYEjh4AvAov5qvbEP7kBNL1h3Symz7tfzeZ9u3jo9Oj0YPjn48Oj16ePyN0ePvF2W4TCGklQ3nB/k10+7j/F6NHGzlF6EOrfzEg6PqwVEROKqE46f5tSZkjG3lTeIdo1FCfG3F4atbJnIi/XpcPU2mlVvED+vnuaeVW0I4rMeSEDF7tkz/1wrgeFppNLZLCmfw1wX8tuCnKWS87mnHTsW8MK/cAQ0mK5HDZOn1D6Nfd1E7TsdnS9TPczvqtkdIdtRY6x9FzlIkOD7jvBTbbxMu5eBKiQZ/Q8BfBxjuEEjvRglcPto3BTzirBFt5OtmCVw+2rcEPOJcJdrIl7WtCTr7+bW9UOkeNIRcHCBuwfOAHXJQNkAY/brQX4wA4bNZVszGprvbgteWqOP+eFvQuS3oKFzbAXFdD4jL/FcNbNyXVMaw5aGD7Q0uYN/o84OakC/gms5985+X3GyxupeFzImAV+s2xneWtX91jnUb9K2XqQ595RWqw9j1KtVhDHktv1c+wn49r4+o8c+XBJWJQYqO4lmNXdy35h2Drws6DdFuUXkUz2zzEHRQnhtE50ZAOmocVWsOlndkM86P4Tm2q7qprbDtCtQj/L+SKc4/5s/ijqWdEY9FWDjOqL6BcYb97BWoY994FepQ51xUfDJdZPHpO3PEJxwHTKZ4OVJ77OtvNTfr15/HJMro191sf46RI/kmuFnhHOmG4FX1Vc6RVK5/Q9BRuDYD4jKfawrcPGZtCjqbHjrbgueA6909fnDVYpFv3fyiuDFPXoO+9RLVYf/lnAf9gHMejEUWC5WPsF/P6yPYvswqZJm4oegonn2LVImbjbtl8rTrgk7sPO3/La+5SXSK8prlZPoc26m8Jit3z6b1CP8J5DWr+X3cRcTOUK1POJIb4xj3DTX/VjGIfQPzoXnzGtPFvHkN2u8WwZpc/H4O21UJ9sVkysfx0nl83Ea9r8sWQG2vw2QB9Lvp8Tg9SQrYUyrigqZQ5HnYtro1wb4P120Q/4e0fxvNtp9f24uVyX7QOvEZBn+nq8K9Fd82D/WirUF12H1foDpObbEOuwZuXeKiugna9bREN4lou+4X3Xa4pYnLVbVdfgakl4Up0880TJ0+PBm9m76djsZJAe+Jh1+OMU7Amo18IbRKsAOISR9STKq7cLrJyvip7PIdVq6bd06OTlNHpeg9kyMm1S4EFCZCJ+0FF2ZDwGGZZ/OPz1sY53XGee+9o9Nvvf/gwdHhUXrCLcpSsvESt6ZZeqfOnVhaj35rbSPvje8mbtYivBcd6ctU5O309P2TY0el6NX/kptVX72gTQXgseDRghiePjwYdQc7w5T5U0fBijK4e5Clf5TfqyOJdh/52GTpFSx7Vi+QdT8MPx2f6yGPz70NoOIRkh0q1jaAiqDpExyf8ZRTGanhdERVV+f8U1ve7rcILuNXbS/2wTcEfNntxY0SuHy0rwl4xMnbE5Ava2u2Una3Oozzq0QPz5gVbYlORHvEgee8NgpwrAq5nJsGoUhnnw7UsR0rars6+znObYryR+d0rmwyzbt9HvXJPlYnmqxP9jGVE6Ac7N8Vwf882RDy7ivz4KzPgfMm45xkV/d+dPT4dAa3OhJh977YjHwVZZE8BzjOEWf+8LOlKc8ll1o+T9U6EqUqeOKcxWAfg9g/p6kPqnQ/v7afs9wfte9399rDyCFlcjy3EQd/zzeUqeFn0WEUadXdrF/EyMGUbMh/mZOSPlwbc+KKPO3plQ3HRadNsW2rgNdQOkkC4loNiKtGuFQqonxIDW3WNvJR9cl0NxG8qpQok9feTpxbJPjecXp8cPLk0Wk6/ubDdx0VHqlW4DmbtGjmUTT1bQocnGUo8RLBX6ugPd6vCFy+VQy1MSf2FxR8cuNXIYx+wFWMRUyJKwPqw0NJMBXt9tWHh8Lh3xmo1YuA/O+qj3wE5D9VLhqQ/66KbAH5P1AvTsLh77ZVFheQ//tqxA+Iv6eyxID27anvNwTk/1B9eyAc/sFAfXvAYpHRxnO5AV/KdRKi55zOio1+nXgNPJxMsmLf9wiywgtnm4JXtZ+HbTjvHiTEtRIQ1/oV5etaQFyVKypjPSCuRkBcSwFx1a4oXxsBcSUBcYX0e85rjE/86Btu7LHT4fzG66/5jconY2zUUC824n7wrVP6ZDd/FJH5yUpd1C0vwGs6GB7uDQd7T1OOzs7T5bWE8Buv/Iz7i5qtq7Et7oz8s28ePePhbIp/FfSalWWoW6G6KtQZj5kf/4JWNuNMPTul9I/0W077g93PY8tNd97XsD9mYznvG/1b7rwZrn9SP450tnSy0mb7P4vO8OAZH4T/R85nZtNfL53Xkzofqs4+MA8Iz3JnpUl6w7ZXdc++75zi854fsrrXoA51wqVC/6OeMvt9VOKlG/pmQjSNBvtOjfitCH5x/zWfE/sP9ItVihtxzpx+thsDbVnUL7DfIPynnn6h/Fydm2YeEJ7lzkrTzfo+n/u6amd0le/zuTr0fe4X6PvcL74EdagTLqpf4Jngsv1itUT8K9svbgHej/N7g18+m8KFsuHusN02eWysr7pZ3SD9KsE3c/n5LemiOdXh7qhz2Bsdjgaj8bh/MFKb6HFcxQ+R+zb6NIE3q+O8KvaHvS3vwPiiPuxdJfgbOaMqvqj8RG1cYh4QXuU/pi/8UDTmgkzb9HwZrxeQnsmBz5C+yvljrE/59JoVXp9aE7y2RB1/GDzSh8q9ciwLfhLidaUAHn0e4d8An/7z0nn5E5IR65YE7oZoZ7q/jB8rsFJmnhzpw+6ld5Qa/bqbjZUx/El9+F7FJ9Od+ki/+oA/x7VFfgwgBi413vC4pHSz7KGD7Q2uIdqxz0WKGaW/VcQ/MhGpD3h/ZELpVa0VVUnnWMd+UnZt4H8JF/sOx+L9/P/2gkWtWToXPharvtnwyN0QfBX1NcTfKNAX1qntGEU5rO/HSpDvkDrjHKBo3C/KU9+hMZYPp+4H4lN9hXSNdBQp5u2o3NdKg/Sh/Ap1wv7I67pYpzYmJ4IHNb81XWS0/1Jifqt8MKE6FX+sjnP/rKjcjmMt9rkVqvPtUONxaD+/thcrHaPNa8JFtEP6eEJyO1fuXYIv31J29MU5lA3n3MHn/P1htty6M9gb97q7/e5Fc/7Q9DuHT5OZp++a+u1uv9tN03nWHAyO44H9sBvqdd5DudiPHNUp2gzHcTgr+/m1vWAxehazqoLnNaoz2J/A3O/DgndDoXgNcuCXFzpWBRyWhQlyNl+9gGCkXjHqjru744Nhd7g7uvReeT/tpL3Dw8NeOuof7hyOLpv+wc6oP94dDwe9bjq4P+xcRN+er55N6y3yVuBZNb+3EXgN4amuBnXLZ+fp1/P/7SgZ4zI+qgT/K8g0s7ICbax9S9BfIfrn+BbPOLOvCfiagM862y/zf2LYNR3ujdt7h+mo0+l0x+30eVaY1e4Clf1w5h7rZ+VstJ68NQA6ZSLybygKRzrjIjN33m2Fsw+V8dw9O89rrJVdHtH+kOsoo/db8geV8TddccbfJP0rP1IZ/2WdxZns6HBTG6ijrFWC/514U+HbVRLzLdfT0s/4eLUy5SPDj+eMqkAX5XJuKrf6GUDWE8KrcznqF4F4dqVWrVDnvFphOlwpgOddYwb/+5Ir73ymCmVfo7qKoKtmT3Xg+U8FmV9gHxjyzBuLmnknVIf9kGfsfI4S69RR+UTwoGbspot5Z+wh4hDHmlhjwRc5LphOfXEhZJ/k1RT0R9M19skYeVd/MNo9GO12Onv9TtrvDObJuyKP9e3IMaijVqNXQO+fFLzVx/EXx4e7Z9N6hP835Ch/96woc2yYdzVPxRSOG5HOjfZ9Z7ojn28v/cbL6F/WmXF1dlqtEkbOH/u++KfOH2cnc665WZupX5pUMUv5L88n5n0bhu05bqKNfavXHN/V6rWKxdaf1p1/rpkQvIoT3LZIF2qHD+/W+BTiyss5EyoGcFzBGMBxhfsE1vl+lTnStyUmvnvtAp02SEeTkyG5EGqXluoPvk/TXPT5oyrpS33+SJ2CjDFXbF6gr2ukr8mvG3v0peRf8+hL/QL1NY++UJfYlmkXxaLL8sWLdMu+aPAtoVuVb9dAnqwsn0WRZ6Dybcypq0C3qL+ob2H47O/LqfHUJ38uDGM859RId4PqMDZz/McYb7ENY2nZ/FCt2aI9s2LrvrgujPAmQ5Xgv1yZ0nsd+HoGK+hlcD0PXFJwfYZDPFs+O/9MrRfjOrrBG+362SyPVrcOdehrWdnI/0d9IS7jo0rwbRgHs4Jr39a+JeivEf1zfItnvI6+LuDXBXxmn6/kAJPvTwHt0HnoM5qEH58xb+Y7WX/4L6x4EcE0jwAA","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTyw7CIBBFqcUo0sTEx39MU0y7dOHafyCtLHVRN+766dZkJkyI0QVwEzJMgMNcHoXwKjBKESGCHDEqjAs2Xs7tjDnEqVbBvin5HRijvvhLWH+jkFnk4QPxM50/rJBzmTyfe6F913PTrF8J/z5y+af7y+l//8OzRq9bzCvh/8P4uvfXx/M2ij/SbJGc0ptoOwAqvkT+EvmhJBvn8w+Yb4Svj6KMqNO1tnaNdfZkh8H0dhfwP+KH/QbzqHp4zgQAAA==","debug_symbols":"bY/dCoMwDIXfJde9aPzd+ioypGqUQmml1sEQ333tkK3bvAmc8OWQb4OBunVqlRntAqLZQNteemVNSNvOoHNKazW16Rp4HJi/+GWWJsbFS+dB5BkDMgOIgofrUWkCUWU7+wOR80t9sMgRizeOeXnKY119+Gv5xd/2EO/SKdlpOl4fV9MnJv4x04/U7GxPw+oo6iVmYTZYsoyH2lD9BA==","brillig_names":["sync_notes"]},{"name":"withdraw","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"9385570459966878761":{"error_kind":"string","string":"Not an operator"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_data_witness","field_less_than","decompose_hint","lte_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","enqueue_public_function_call_internal","directive_integer_quotient","directive_invert","directive_to_radix"]},{"name":"init","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[{"name":"donation_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"operator","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"deadline","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2236649814169388962":{"error_kind":"string","string":"PublicImmutable already initialized"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["init"]},{"name":"donate","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3151558035338938026":{"error_kind":"fmtstring","length":75,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7764445047318889914":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9199403315589104763":{"error_kind":"string","string":"Proving public value inclusion failed"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_data_witness","field_less_than","decompose_hint","lte_hint","store_in_execution_cache_oracle_wrapper","call_private_function_internal","store_in_execution_cache_oracle_wrapper","random","notify_created_note_oracle_wrapper","debug_log_oracle_wrapper","get_random_bytes","build_msg_block","attach_len_to_msg_block","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","directive_integer_quotient","directive_invert","directive_to_radix"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"_publish_donation_receipts","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"parameters":[{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14313802839798733697":{"error_kind":"string","string":"Function _publish_donation_receipts can only be called internally"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VXbYvTQBCevF0vd9YWBRH8E0mTXiIoVLR+Ev0g/oBtd1cKd72jraLf7qfb4ozdTjaR0l3xBsJsmOSZeZ6d3U0C+G3h9gpwHKOPoGn0zAR9dprlDrEyn3UGD6TO0FOdB80QYMO0GZF6iz5FHxrxyCHplOV1iV9nZZVa+Dmsv0gRM/aMn/jBz3qI8+5+j29yobx9vA8MLekdipl9NWUxswffY+x8ez2G/XiA45Tl8tETZr2uNX1qqZ9yXSLXCu8fba8hjsX3m09381up3ki5Uuu1qTWfly47BjM5AvM5x/z47fp6oRdqNf2xWG8a2GcWbBqHYOfG62rbq2zrbmcT9NlplieMwzP0u7l7bWgy4Jp8VkupVv/T1AGjkkD7Mue0X6Df0Z7gmEsPcLrsM5HNRi+zOoVm6zhcmiXhn/vBL2jZ9wxtIgsnyt9n+lPc5gmLxyjXBXg9KvIubmb9tGSH7HmuQRtW70is1BLzMadnHbzN/P2OWocttbrSJHCIFTrEor3C59G+tTKA5t7U1aMDaM4Br9XTXjQKmM5mrebeTPl3ZwPtx3/OhunNYvNlqZbz1c+7jZIfbr8CM37Smiew7SvI9k4Eh7+ZZJew/0OI793LVNVZRjkjxE/A/nsbG3Hz+Vd4f2HwIR+fUKeuRK4LocVYSFnOxROGD3D41ec6/0zlqtBaF0qU+kr/8/zzK1HKStbjYqTGszr/W/5f/EMQ868QAAA=","debug_symbols":"3VnRisIwEPyXPPchm2w2ib9yHFK1SqFUqfXgEP/90sOUWovlNN7Dvkgjk+zMJC1D9iw2xeq0W5b1dn8Ui4+zqPbrvC33dRidL5lYNWVVlbvl8G8hux+gX/zxkNfd8NjmTSsWQF5moqg34dFKGVbYllUhFqQu2T1YShPBUpke7P0EGBHtFYxoqAdbmAA73a/stIIh+DMTYBNQdyqCA/f/o+4SUEfoXacZ18FQDyawj6l77SPYo8YxdZ+UOsgb6qGAku8uAO8uoF4ugKRigfDo586aVf1Zc3a0YUq/zibdyVf4RzbdHPPEHHpizuQHRRNFd7WV9NgpK90Va2EG6mTcYTd4I4FoAmtcXJYAZrCO4l55eee+Y6/Qc1eoJXuFwF6hYq9Qs1eI7BUa9gqJvUL2mUazzzSafaZB9pkG2WcaZJ9pkH2mQWSvkH2mQfaZBtlnGuSRaUx/jyxvrpEn7pyNi5eGnoDGdvAIQKnsMDzSUjI7eESrZHbwyGHJ7OAR2tLYcQmjr7wp81VVXFvD21O9HnSK2+9DMWoaH5r9uticmqJrHw86x91XyJiMZHAZuncw9BhJhxqhzg8=","brillig_names":["_publish_donation_receipts"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Crowdfunding::init_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Crowdfunding::init_parameters","fields":[{"name":"donation_token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"operator","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"deadline","type":{"kind":"integer","sign":"unsigned","width":64}}]}}]},{"kind":"struct","path":"Crowdfunding::_publish_donation_receipts_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Crowdfunding::_publish_donation_receipts_parameters","fields":[{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Crowdfunding::donate_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Crowdfunding::donate_parameters","fields":[{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Crowdfunding::withdraw_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Crowdfunding::withdraw_parameters","fields":[{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}}]}}]}],"events":[{"kind":"struct","path":"Crowdfunding::WithdrawalProcessed","fields":[{"name":"who","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"struct","path":"std::uint128::U128","fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Crowdfunding"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"donation_token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"operator","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"deadline","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"donation_receipts","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"UintNote"},{"kind":"struct","fields":[{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"51":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"52":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"62":{"source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Crowdfunding {\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public},\n            storage::storage,\n        },\n        prelude::{AztecAddress, PrivateSet, PublicImmutable},\n        protocol_types::traits::Serialize,\n        unencrypted_logs::unencrypted_event_emission::encode_event,\n        utils::comparison::Comparator,\n    };\n    use std::meta::derive;\n    use dep::value_note::value_note::ValueNote;\n    use router::utils::privately_check_timestamp;\n    use token::Token;\n\n    #[derive(Serialize)]\n    #[event]\n    struct WithdrawalProcessed {\n        who: AztecAddress,\n        amount: U128,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        // Token used for donations (e.g. DAI)\n        donation_token: PublicImmutable<AztecAddress, Context>,\n        // Crowdfunding campaign operator\n        operator: PublicImmutable<AztecAddress, Context>,\n        // End of the crowdfunding campaign after which no more donations are accepted\n        deadline: PublicImmutable<u64, Context>,\n        // Notes emitted to donors when they donate (can be used as proof to obtain rewards, eg in Claim contracts)\n        donation_receipts: PrivateSet<ValueNote, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn init(donation_token: AztecAddress, operator: AztecAddress, deadline: u64) {\n        storage.donation_token.initialize(donation_token);\n        storage.operator.initialize(operator);\n        storage.deadline.initialize(deadline);\n    }\n\n    #[private]\n    fn donate(amount: U128) {\n        // 1) Check that the deadline has not passed --> we do that via the router contract to conceal which contract\n        // is performing the check.\n        let deadline = storage.deadline.read();\n        privately_check_timestamp(Comparator.LT, deadline, &mut context);\n        // 2) Transfer the donation tokens from donor to this contract\n        let donor = context.msg_sender();\n        Token::at(storage.donation_token.read())\n            .transfer_in_private(donor, context.this_address(), amount, 0)\n            .call(&mut context);\n        // 3) Create a value note for the donor so that he can later on claim a rewards token in the Claim\n        // contract by proving that the hash of this note exists in the note hash tree.\n        // TODO(benesjan): Instead of ValueNote use UintNote to avoid the conversion to a Field below.\n        let mut note = ValueNote::new(amount.to_field(), donor);\n\n        storage.donation_receipts.insert(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            donor,\n            donor,\n        ));\n    }\n\n    // Withdraws balance to the operator. Requires that msg_sender() is the operator.\n    #[private]\n    fn withdraw(amount: U128) {\n        // 1) Check that msg_sender() is the operator\n        let operator_address = storage.operator.read();\n        assert(context.msg_sender() == operator_address, \"Not an operator\");\n\n        // 2) Transfer the donation tokens from this contract to the operator\n        Token::at(storage.donation_token.read()).transfer(operator_address, amount).call(\n            &mut context,\n        );\n\n        // 3) Emit a public event so that anyone can audit how much the operator has withdrawn\n        Crowdfunding::at(context.this_address())\n            ._publish_donation_receipts(amount, operator_address)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _publish_donation_receipts(amount: U128, to: AztecAddress) {\n        WithdrawalProcessed { amount, who: to }.emit(encode_event(&mut context));\n    }\n\n}\n\nuse token::Token;\nuse dep::aztec::test::helpers::test_environment::TestEnvironment;\nuse dep::aztec::prelude::AztecAddress;\n\n#[test]\nunconstrained fn test_donate() {\n    let mut env = TestEnvironment::new();\n    let admin = env.create_account();\n    \n    // deploy token\n    let name: str<31>   = \"Test000000000000000000000000000\";\n    let symbol: str<31> = \"TST0000000000000000000000000000\";\n    let init_token = Token::interface().constructor(\n        admin, name, symbol, 18\n    );\n    let token_instance = env.deploy_self(\"Token\").with_public_void_initializer(init_token);\n    /*\n    let token_address = token_instance.to_address();\n    // deploy crowdfunding\n    let init_crowdfunding = Crowdfunding::interface().init(\n        token_address, admin, 1337\n    );\n    let cf_instance = env.deploy_self(\"Crowdfunding\").with_public_void_initializer(init_crowdfunding);\n    let cf_address = cf_instance.to_address();\n\n    (env, token_address, cf_address, admin) */\n    /*\n    let (mut env, token, crowdfunding, admin) = setup();\n    let donor = env.create_account();\n\n    env.impersonate(admin);\n    Token::at(token).mint_to_public(donor, U128::from_integer(50)).call(&mut env.public());\n\n    env.impersonate(donor);\n    Crowdfunding::at(crowdfunding).donate(U128::from_integer(25)).call(&mut env.private());\n    */\n}\n","path":"/Users/seppi/repos/aztec-tutorials/contracts/crowdfunding/src/main.nr"},"63":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"70":{"source":"use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"71":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, Packable, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"72":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        /// Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"73":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"76":{"source":"use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        /// Safety:   Unconstrained logs have both their content and encryption unconstrained - it could occur that\n        /// the recipient is unable to decrypt the payload.\n        ///   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can\n        /// have more than one log and removes all of the matching ones, so all a malicious sender could do is\n        /// either: cause for the log to be deleted when it shouldn't have (which is fine - they can already make\n        /// the content be whatever), or cause for the log to not be deleted when it should have (which is also fine\n        /// - it'll be a log for a note that doesn't exist).\n        ///   It's important here that we do not return the log from this function to the app, otherwise it could\n        /// try to do stuff with it and then that might be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"77":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key)\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"79":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, hash::poseidon2_hash,\n    point::Point, public_keys::AddressPoint, scalar::Scalar, utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    /// Safety: We assume that the sender wants for the recipient to find the tagged note, and therefore that they\n    /// will cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to\n    /// find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\n// We return [Field; 1 + (M + 30) / 31], where M is the byte length of output of encryption because\n// each field (apart from the tag) contains 31 bytes so the length in fields is computed as ceil(setup_log_byte_length / 31)\n// --> we achieve rounding by adding 30 and then dividing without remainder, then add one for the 32 byte tag\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; 1 + (M + 30) / 31] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M] = compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    /// Safety: We assume that the sender wants for the recipient to find the tagged note, and therefore that they\n    /// will cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to\n    /// find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    let siloed_tag = poseidon2_hash([contract_address.to_field(), tag]);\n\n    array_concat([siloed_tag], bytes_to_fields(encrypted))\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; HEADER_SIZE] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    // Nargo seems to struggle with realizing that `offset` is a constant at this point.\n    // We then redefine it in terms of the assertion above to give nargo a hint.\n    let offset = M - incoming_body_ciphertext.len();\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    /// Safety: A malicious sender could reveal the whole contents of the encrypted log so trusting it to set\n    /// a random padding in plaintext is fine.\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    /// Safety: We use the randomness to preserve the privacy of both the sender and recipient via encryption, so\n    /// a malicious sender could use non-random values to reveal the plaintext. But they already know it themselves\n    /// anyway, and so the recipient already trusts them to not disclose this information. We can therefore assume\n    /// that the sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8; P + 16 - P % 16] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"83":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"90":{"source":"use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        /// Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"95":{"source":"use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/10537): Replace use of sha256\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr"},"99":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"108":{"source":"use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |serialized_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(serialized_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::deserialize_content,\n///             note_header,\n///             true,\n///             serialized_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, serialized_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                serialized_note_content,\n                header,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        serialized_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let serialized_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, serialized_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr"},"109":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"111":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"119":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"121":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"122":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"123":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"124":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"125":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"129":{"source":"use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"130":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"131":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"134":{"source":"use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr"},"135":{"source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"137":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"146":{"source":"use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"148":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_PACKED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::unpack(fields)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"166":{"source":"use crate::{context::PublicContext, event::event_interface::EventInterface};\n\nfn emit<Event, let N: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; N + 1];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_public_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n{\n    |e: Event| { emit(context, e); }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr"},"169":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"170":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"174":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"192":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"227":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"234":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"249":{"source":"use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr"},"250":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"251":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"252":{"source":"use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr"},"261":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"267":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"268":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"277":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"297":{"source":"use crate::traits::{Packable, ToField};\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for U128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self.to_field()]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"298":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 2;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        // We use little-endian ordering to match the order in which U128 defines its limbs.\n        // This is necessary because of how Noir handles serialization:\n        // - When calling a contract function from TypeScript, the serialization in encoder.ts gets used and then Noir\n        //   deserializes using its intrinsic serialization logic (based on the limb order in the struct).\n        // - When calling a contract function from another function, the `serialize` method is invoked on the type\n        //   first.\n        // For this reason if we didn't use the ordering of U128 limbs here and in encoder.ts we would get an arguments\n        // hash mismatch.\n        [self.lo, self.hi]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_u64s_le(fields[0] as u64, fields[1] as u64)\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"314":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"315":{"source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"317":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"322":{"source":"// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n","path":"/Users/seppi/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr"},"326":{"source":"mod test;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n/// The purpose of this contract is to perform a check in public without revealing what contract enqued the public\n/// call. This is achieved by having a private function on this contract that enques the public call and hence\n/// the `msg_sender` in the public call is the address of this contract.\n#[aztec]\ncontract Router {\n    use aztec::{macros::functions::{internal, private, public, view}, utils::comparison::compare};\n\n    // docs:start:check_timestamp\n    /// Asserts that the current timestamp in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_timestamp(operation: u8, value: u64) {\n        Router::at(context.this_address())._check_timestamp(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_timestamp(operation: u8, value: u64) {\n        let lhs_field = context.timestamp() as Field;\n        let rhs_field = value as Field;\n        assert(compare(lhs_field, operation, rhs_field), \"Timestamp mismatch.\");\n    }\n    // docs:end:check_timestamp\n\n    /// Asserts that the current block number in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_block_number(operation: u8, value: Field) {\n        Router::at(context.this_address())._check_block_number(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_block_number(operation: u8, value: Field) {\n        assert(compare(context.block_number(), operation, value), \"Block number mismatch.\");\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-contracts/contracts/router_contract/src/main.nr"},"328":{"source":"use crate::Router;\nuse aztec::context::private_context::PrivateContext;\nuse aztec::protocol_types::constants::ROUTER_ADDRESS;\n\n// docs:start:helper_router_functions\n/// Asserts that the current timestamp in the enqueued public call enqueued by `check_timestamp` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_timestamp(operation: u8, value: u64, context: &mut PrivateContext) {\n    Router::at(ROUTER_ADDRESS).check_timestamp(operation, value).call(context);\n}\n\n/// Asserts that the current block number in the enqueued public call enqueued by `check_block_number` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_block_number(operation: u8, value: Field, context: &mut PrivateContext) {\n    // docs:start:enqueueing\n    Router::at(ROUTER_ADDRESS).check_block_number(operation, value).call(context);\n    // docs:end:enqueueing\n}\n// docs:end:helper_router_functions\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-contracts/contracts/router_contract/src/utils.nr"},"329":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n            },\n        },\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: U128,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> U128 {\n        storage.total_supply.read()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> U128 {\n        storage.public_balances.at(owner).read()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: U128) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: U128, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: U128) {\n        let from = context.msg_sender();\n\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount }.emit(encode_and_encrypt_event_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::zero(), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining)\n    }\n\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: U128) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            amount,\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: U128, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: U128, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: U128) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: U128, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    /// This is a wrapper around `_finalize_transfer_to_private` placed here so that a call\n    /// to `_finalize_transfer_to_private` can be enqueued. Called unsafe as it does not check `from` (this has to be\n    /// done in the calling function).\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueued call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: U128,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: U128, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: U128,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: U128,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:setup_refund\n    /// Called by fee payer contract (FPC) to set up a refund for a user during the private fee payment flow.\n    #[private]\n    fn setup_refund(\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        max_fee: U128, // The maximum fee a user is willing to pay for the tx.\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by FPC when setting up a refund so we need to support the authwit flow here\n        // and check that the user really permitted fee_recipient to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Deduct the max fee from user's balance. The difference between max fee and the actual tx fee will\n        // be refunded to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            max_fee,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        // Emit the change note.\n        storage.balances.at(user).add(user, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            user,\n            user,\n        ));\n\n        // 3. Prepare the partial note for the refund.\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 4. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        let fee_recipient = context.msg_sender(); // FPC is the fee recipient.\n        let max_fee_serialized = max_fee.serialize();\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\"complete_refund((Field),Field,(Field,Field))\")\n            },\n            [\n                fee_recipient.to_field(),\n                user_point_slot,\n                max_fee_serialized[0],\n                max_fee_serialized[1],\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // docs:start:complete_refund\n    /// Executed as a public teardown function and is responsible for completing the refund in a private fee payment\n    /// flow.\n    #[public]\n    #[internal]\n    fn complete_refund(fee_recipient: AztecAddress, user_slot: Field, max_fee: U128) {\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(max_fee >= tx_fee, \"max fee not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and the tx fee.\n        // TODO(#10805): Introduce a real exchange rate\n        let refund_amount = max_fee - tx_fee;\n\n        // 3. We send the tx fee to the fee recipient in public.\n        _increase_public_balance_inner(fee_recipient, tx_fee, storage);\n\n        // 4. We construct the user note finalization payload with the refund amount.\n        let user_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, user_slot, refund_amount);\n\n        // 5. At last we emit the user finalization note hash and the corresponding note log.\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: U128) {\n        _increase_public_balance_inner(to, amount, storage);\n    }\n    // docs:end:increase_public_balance\n\n    #[contract_library_method]\n    fn _increase_public_balance_inner(\n        to: AztecAddress,\n        amount: U128,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n    }\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: U128) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub U128 {\n        storage.balances.at(owner).balance_of()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"358":{"source":"use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/uint-note/src/uint_note.nr"},"363":{"source":"use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\npub(crate) global VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}