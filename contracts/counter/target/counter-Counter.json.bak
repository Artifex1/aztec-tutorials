{"noir_version":"1.0.0-beta.1+4ca7394b2efd7aef","name":"Counter","functions":[{"name":"process_log","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"log_plaintext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"tx_hash","type":{"kind":"field"},"visibility":"private"},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"first_nullifier_in_tx","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6753155520859132764":{"error_kind":"string","string":"Failed to deliver note"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8861757336002045335":{"error_kind":"fmtstring","length":99,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"9862881900111276825":{"error_kind":"fmtstring","length":35,"item_types":[{"kind":"field"}]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dWY8c13Wunpkecno47Da1UCK1ULsoyVJVd1Uvpig2dw6XkaiFcl6S9CoTYSSYpAMYAYIB/BAgDwYSBFCMIDESxEAeAuQxeQgC5EckSBAHfgmQhxh2kAUw8hBkrlyn5+PXp+9Uce4ddsm8ADnVdU6d891zzz13ryoFP083tv6V0uul9O++9K+5fyi4NwlvN/0b7i5FDmWFvjCWCoBxoQAYFwuAcakAGMsFwLhcAIz7CoBxfwEwrhQAY6UAGFcLgPFAATCuFQDjwQJgrBYAY60AGL/iAaMPnIcKgvMRhzixb+8L76PB/PvoYwXA+HgBMB4uAMYnCoDxyQJgPFIAjEcLgPGpAmB8ugAYnykAxmcLgPFYATA+VwCMzxcA4wsFwPhiATC+VACMLxcA4ysFwPhqATAeLwDG1wqA8fUCYHyjABi/WgCMbxYA41sFwBgWAGNUAIz1AmBsFABjXACMSQEwNguAsVUAjO0CYOwUAOPXCoDxRAEwvl0AjCcLgPGdAmA8VQCM3QJgPF0AjGcKgPFsATCeKwDG8wXAeKEAGC8WAOOlAmBcLwDGywXAeKUAGK8WAOO1AmDcKADGdwuA8b0CYLxeAIzvFwDjBx4w+sD5YUFwflQQnDc84Qw+JtALW//MwS1zMMocPDIHe8zBGXMwxRz8MAcrzMEFczDAbLw3G9vNxvHa1j+z8dlsKjYbds0mWLPJ1GziNJskzSZEs8nPbKIzm9TMJjCzycpsYjKbhI5t/Xtu65/ZRGI2aZhNEGaTgVnEN4vkZhHaLPKaRVSzSGkWAc0im1nEMotEJldmkcMsIphJejMJbiaZzSSumSQ1k5Bmks9MoplJKjMJZCZZzCSGTBKYQa4ZRJpBmhkEmUGG6cSbTrLphJpOnulEmU6K6QSYRtY0YqaRMEHYBDkTREwlNRXAONeNYHYSJ2mlJzBX0t8LQHd4iC5aIb0u5bfDTm9FyZ9D/I2VVOZ+L/KTlshf8YM/lIO2Zze35WNeRO9i+vejzW1bfrR5Lybh+Rx4PiceyY+f8o4bfu0V1dfIRgHkRXRX/OhulEgflgvSRH8l8OmbPz+UjPoED9tHYsea8Gxu4ykRbWlzOh9CKwNNytfoOQ587Fv7iSZYTBL/XQPbSLqR0qRMl0CmO3/1Xb/j8MH5axx9Gf11iWhLm9P5yOuv6Fvsr+VgO0ksFdoy0P6AaPuA9r3Nbd1xes9vHP55u4v1zXW79YiCH3WZtG9z2wbid4twrww2+8I+yE+0FaAtbd6rp5L+XgI9KEtwlIm/kf6upn+X4Rl5vqboXyb99+BW7rFdVhT+FYXf+Ncb6bXpXxv/+V6aCdPXPpjSPhndPXPrs8GvbXzr1/uj21jbObLhfYy2kozUQ9tSz3726d3bvcHd08Ph7dGdOyyhokgOZkitgNRv9G5+uj5kaav3J+3G6Padm599ytIOZJQm9WQN+B3Wk7rUESmrcrAd89Av1ghPFWiBOzyh4BG/xth3EK6rgBf5u4TzK37sFh6i/KOuFQWvS91sIywz1LlgsYXDMou4DM6nf008+H55W6f5hy/rWQzujdFBcK/PmX+PKPxoe8lvlTDgsyvKcz76DaKvPAPrAtCR/6rFXo8G+ez1mML/KPAcIns9ArTHyF6ouxs4sdWkv4k4ub/5ONx3OD7K3N8U/RXC6stvHic8bB+ux4f92GcSVw4reA4r9pGyfEKhiawn099YJ5D/MOQR+fFansd7v5z+rSkyHyUMTwTT+cF72J/5OuUNy6Y046/I5XsLhBFtw3XNj49FU+M7jJkmv0O4j+WB5bVfwV0m/t8qb8v8JL1XVZ5n/+C6PqvfwfiWgR95Fmbgu5X+NVj+lGLsgpLnxyyYhbak6NX6JsL/zfSv33qs902wTtvaIqw/mm+WnOFsRpod3MlvtUX+E37w10X+k37kD0T+ET/yJ3OhR/3YvyPyn/IiP05E/tN+7NMU+c/4sU8s8p/1I39in2N+7DMp3+f8yJ/MfT7vRX4yFvkv+ME/kf+iH/kT/3nJj/yRyH/Zj/xJfH7Fi/zWJD6/6kV+PRT5x/3YZ1J/X/Njn77If92P/Il93vAjfyh9268G20n6PKL7Tbjvro/VjEukLwj0saTorxBWx32+yVjyTcLD9sG1C0N7S8FaU2jchr+l6HlL0aPJOuxQ1usOZR13KOuIQ1nPzGkeX3Qo61WHsl5yKOsFh7LmtRxd2t6l37u0vUufmNdynNc8uvQvlz7x9Jzm8UmHsubVv55zKMulr77sUJZLn3jNoSyXPvGwL/flaDtc9uWedyjrFyEWvuFQlsuY84RDWc86lDWvfZPnHMqa13HHvLZpjzmUNa/x3mUdcmkvlzH6Ydvx5Wg7XI6tXMbCVxzKejhn9eDqkEvbu8zjUYey5nU85NL2xxzKmtf5aJf9nIdxIp8sl/2Jh3Hiwdn+mENZLuOE9L8875Xre94r1/K7Vy5JZL0Z9/SWyHY47nK3Nl7PvFYv+iuE1S2e7bX6I4SH7cNr9U8pWGsKjcvwKUXPU4oeTdZLDmU9Nqe4XnAo6/Cc5vHVOcXl0vbPOJR13KEsl7Z3mcejDmW97lDWvNr+mENZL85pHl9zKOthnMgn6/k5zeMvQpxwaftjDmW5jBMyVslyBtPT2aSkRPokH3gP9e/VGUztzKN2BlM783iYbO7iLGIRZbHvmNRN/4a7So14TcHEPutn/BiOsvosjx+f8IPHOn7Uykw75+UQz7BE8hHPUcU+tvGsyJL1IzyTqbVJC8SP1/I83vvbtMBcjt3MWdS/TuX6qwNhxH5ukV0fjKNGMmolYbMXJ8Nmoz6st8JhnIyjqB3VO3G70RgP4vawXW+M6636YC2YLkOuX2grh/6TeX5G9FcCr/4c2cof7cNtwtMK1ppCYz97WtHztKJHk3XEoaxqeu0xjk/mAdGH98jP6vfrZ57aFaufoX1262ceY1JjRcnDfcpu8A0+34uy6+16Mmh1BoNmLxn0+6PRuDVs9trjqN/sRfV+I6r3eo1GO47D3mg86seNTjOK24N2J4pbgzDuaGd7HZZtQzvb61D+QDvb61B+Tzvb605+HPLZXizbrfapPx5Gw14S91thsz5s9pM4HrVGjWa/E7YazUYSjpvjfi+M6vX2II4GrXrY6SRhZ5y0wmiknet1aJu2dq7XZX+Kz/UG9y97yDf4TO89skfDfjSqdxqDxmDUifrjrYoy2rrs9ZJwWB8kcTTudYZhx9h7q0qFjdG4Hw3Gvfqg32gkrTGf590Fbk7qWV6HNu9rZ3kdym9qZ3ld9qH4LK9D24/5HC/KjhpxNGy2knFvK36PBqNGFDV6w6Qx6DXirTrc6EedfnPUaTXrYdxsbd2Lt8JwPR7EW9F6OGokfE73HtzxVv1ubAXsfrMdtrd8cNCuj9q9JOl1kvowHo7rYT1pjkdh0mkMO3Fn6/ZWLOhtIQ57/XE0kf2WH5tP2pDQj/zJmmzkR/7EPnXN9r22qeXNrQiy9d84GbbDOIk7w7g9boRxPAy3mtOw32mPhq2o1ev0k0a9N242wkGUNMJWJ9LetYvvHfpxafu++SfvusTxHj77HNCR/z9K2zJ/ml6v5pBbniH3v0BuPWWqpjwxPI/vNkJaAPrwHve/8Xl+92oCNJdtr2Bt7mCbhGwj/P+bMhnsP6B3KckzmP8lJf+MAfkT4jFJs708u6boLs34K3r4HpcLYljeIz0re6SnQnqaDvU0gefAHulZ3SM9NdLTcqinBTwyTqsqNI43LdLD92zxprVH+eF3Vrcd6mkDD7+XsONQTwd4HtkjPYuk52sO9XwNePbBc+b3CaChDMHxtoJD2qyThL+b/g53lzJ/20D0VwirYzyTuZuThIftw3M37yhYawptGa6RhnreUfRosk4QhhPw3B6VX/1+y++EHzzW8juh2DVv+b1Cdn3HSz4aY8F1KphOQuuCbvaF00DDusJpkX5jnkx8//PytlzmYzzoY930uhpMlzfycbnYyqqmPC98Uh5+4kJjxH4SKPk/NSOPnDSbC25j87/LYXO0q+iXfr3YrZdemNizvrDNj3rxnadVuP4KyRT+X0nl+I0v9aZmd45tpzzpzhrbRL/mB4K7otCWdoG13R6Ox6NhEiWDRn1rMqYUTMeLReUej9O6Cr+2V1lsfRqed2jrhvbNlS7Y1aQloJ0iWhloghG/ubISTMdMl/iz2B/11xQavt83T1lqsh65T1mHgtntofh3A2iyl8bElqM0ZyDPLYFOfOeyrNGUif83Kbb4aWObba2N5djS9aQ7a2zpku0Rj+CuKLTdxJZWb9yPO0m7VY+G9aTTssUKvMex5bTC/1WFX2x9Bp53aGs1tpwGu5q0BLQu0TC2CEYttviJjc1GFvuj/ppCm/WuY02WSQt7JOtxh7IeuU9ZEvO0drtEv1GW9u0wW7xFmfx9E+w/ncogy6a7q/Br7UxVwdXNIMum+7TCjzLXSDfiwjrJujku+6lr4TBrXBb9Wuz1MZ612dUkHs+eUbDWFBq/z+GMoueMokeT9bxDWVWHsl52KOuNOc3jmw5l1R/m8b7yKLHpLNAcru9N9kqfC6aT0M6D7rxzEIL7i+9rL2/LZT7WeRpo54mGdrqQXq8oWB3aaTJncCGYTkK7CLqx/eOk2Qm/g5bHTugXF4l2DmiX0usVBatDO03GP5eC6SS0ddCNbTUnzU6CO6+d0C/WiXYBaJfT6xUFq0M79dZIX6BgvgK6a3DNSbOT4M5rJ/SLK0S7BLSrRFtX5IoNL8N9l3tqsvarRH8l8Fmm2/2qy4SH7cP9qisK1ppCOw3XSEM9VxQ9mqwzDmWddSjrnENZ5x3KuuBQ1kWHsqROcrspdJP8zoVkP5Mh+ivBtD/7qIda/6ur2NVvHyscCJ5zCp51Cx4/fZmwLXguKHhOK3jMes1yMO1DaC+st4j7Asg3qarI4biWt9+Mz3NcOxtky6OtjDCfBy35kGfnrc/Oe7guzLAXp53680856s+fVZ4VG6JfPYg9IqK/EniNEVEW/zOJ+w7nFaw1hcb7dM4res4rejRZpwkDYuby8xTDMu8REf2VwKs/RTa7nlPsqtXF82RzpPH5rAte8hG3eByASRsHnCMa9q2xrnDSYovkKe8eEfQxwVZVMHB/UGsbtLqm1QHhm7fyQIycdrJ5nj0iaFe2OWLowvX9xB18XvjmbQ4j75zYXs9hoH84tFNHG/szZhz7550TE9x57XRSsYVtfsPvPEXc53F+oGC+CrrzzokJ7rx2yjKfY66vpdcrlA/HdhqwLQIF8zXQnXdOTHDntdMpxRaaf28Q7YoiV2yI5f0g5sREfyXwWabb/aKrhIftw/2iawrWmkLjNv2aoueaokeTdcGhrJMOZV10KOuSQ1nrDmWdciiLYz7u2+Z66GefZ/Y5Md5v5WlP/aQeavs+uopdPY/fJnNi2hzUFQseP32+7TmxSwqekwoenBNDH9Lmvhj3JZBvkrZvheNH3n2btr0/3SBbHkuUJ+TvAs9BSz64z47POew7JGsKVklaH5nnxC7OsBcnrV/RTa/zzolhGV0g2t7vH80+Jyb6tP3nPmJWl/DM8n1tnCTP+p4Tk7LU9t7xmpZ2juikRc85Rc+81SeeB3JVn+73rJBg26vY6rk8vO/T6abXeeeBtFifpd/VhfsOY0bm9y+Kvr3qd3UJz6w6b87By17oT0Z33/tW/9bNwZXRt++c/nT4Xu/23Zu9W6eHw9ujO3cwN6hhDe4jHRPzyPWsGZpqMF1qJ2foxxx2lRxqtahLsrRVkLw9FIyaBy35OJ9Blk231oNFmbwzGnFdyCDLpvuiwo8yeWc04rpIz2HE5llkTTbqtuGx4dd624jjGQv+Sxlk2XSvK/wo8zXSjbjWM8iy6bbtEDLXEelGXJfpOZyBQr5Zsi/vkO91kiGYr+TMo23Gx1wfpzxiPq5mkGXTrc0eoMyQdCOuaxlk2XRvKPwo8wXSjbg26LkNoCHfLNmo24bHhv9dhR9xvGXB/24GWTbd7yn8KPMY6UZc72WQZdN9XeFHma+SbsR1nZ67DjTkmyUbddvw2PC/r/Ajjmct+OXZLD03lOmwp5T5lIzo36ueW9ZyWCNb4rM1hdaF61nl976iR5N1zqGsCw5lnXco66JDWesOZV12KOuKQ1nXHMq66lDWhkNZEkMlpmG58pfNtD7aukUPPs+r7dpu9yzxS9OjYRY9+OYRfCPiDxeDe/ImPohv58NnnwU68g/K2zJ/lMrUZrAEo7QB6FvuYm4SSr6x7Q7IJtj+vATXnLRZDsFtZjnO5JipxTK6TjSs/9yOYn3+gGhYpz5Mr6vBtH13u8qmreSvKc/t1o81zFq95HiZt15eVvT4rpe8onjZoR7MD5+4ueJQD/oi7/aYFWf+j+KMPDcrzrwIdOS/CnGmlL4WSGIJ9oMdxpKI4wUmra/GdeMDoLGffQg09o2PgIY256TFJ7GFiU+jHPEJ21SOQQ/gZFbmlaQvy8ks7tPs5kTPu4RBizV+d2Jl310t+iuBV3+KbHa9rNhV20V0hWyOtNfJrn76N/GI6ysmoeG4nGMLxkqepwvINpi475NnVU3zTa1d57FL3nYdn+f+pqedmUOtH8T535iRR0477czMs6qGdt0gW8yLb+7G/76To23DsufYiOVhGwvyVynz+iY+n6XP6bessrevon+v2tdrGe2q1a1rZHOk8ZhBm9PeUPRosriP/QDa18y7A+ehfdW+YrYX/j2rnG0nZt/1g6cueLQ1Ba3/gbsDZ60toU8i7vdAvkl7NYbO28ey1XnM80FLPrKstdl077TWxmvvtj77Rk7dO62T8do74nrX8hzyaViy5PsyyeD7Mj7HsjhPvBvEa3uDgeRnYQaGDaCjj3NeSgq/Jg/rCMvjN6qYe7y+tq7I0uYeuT3A+YIH0R6I/oqSbx/tgTY3j/bBeLePbM0+g+Wn7UMx15eUvHIcRPm85qut1V1X8NaU56+TrKx5F/4PFH70l4OWfHyQQZZN94cKP8rkOIi45Fmb/2fxT8TFc2guZH3oQJat3IWGdnufaFnm/VC3xI0bcP9BxA3RXyGsvuLGDcLD9tHixqy5hFlrIbN4boBek6rBdBlg/mfhvaHgrSnP3yBZHwfZ8i78X1f4Pwaeg5Z8fD2DLJvuX1L4USbHDcQlz0r/QPoA303n903/93fSa22dgdfRcL2R57BxrUzqnZH/exb5NyzyP7bIryrytbghurS4wV/7wLiBayjou5+D3f7Qove8Re9Fi95LwbT8MtH+CDD8iQXDugXDFQuGa8G0fOkTnlT4kK7t/ZTfmHf0cZTJe1FOKvzYDxd52t5TnmvCPgy35euKHtuJTDz1ruWDbe/SN1if+Mc7ig5+w/5fLm3j/l2Y30MekWGS3zfxZ28b+WsavveTaW/9tu0nO69g1U4gdeEaaagn62mmcw5l8Rta5+VNKfjleE7a/DW+KSXP3hH0b35bXxdoPK+MZcB9TbSvxNtqMG1ffuO8dr4A73E54vN8QhGfK834K3r4HuvRMGd5k3zeL511FT1rynO7zY+GmcvchZ4u8PAJvHMO9Whv99tp78g/Lm3f53ZD2zvCX24R/gT2jvwz7R3xE6vzxxKuGzhOYT/DeZAu0Wa9CZWTFp/EFnn3jmAZcHx6AO12UvR225zgk7e1fTK6e2X07Ru9WzeHvbs3P/v0/dE3vzW6cxezgaKXlGxy8S+ROuHjD20+qvAFxJMnW8LfVfjRFfjIFrqXPPsA3atRdPfSug7cLURalpc/dBU9miwpS61sj5CetxU9b1v0HFH0+PWF/IeqjxANuy15D1zf7wcx0eaCTduyjXzsSzb/qinP80sH5qU8dvMR0jzbcbRpBC4PfHZem0jfHzjWYpjtA8fax7FqCu0MXCMN9WT9iOFZh7JOO5Rl+yCi2ND2QUTU2VB0ZmlnzDVPN6PPZPmAmU33Th8w4+nmvB8ws+nuKvwok/st2hAuID1lBWdMNOF9BYYx9fK9urCsE8IRA61JtARoLaI1gdYmWgtoHaK1gYYffkdekxYJg0nYBV5Nr4ejWzd/Y3R747O7k3dzaOIDul6hew36HdPvEzOg1oivSb85fPMsQIt+txV8WhIcmBjLYrBzEjcSW0Wp65gm7PfTUR66lOhFey0G9+LBqram0ORZI/fHpXtxSPPXAndeT689v6NtsivsEthGm0m4SLYT/hNgux+QvVy/uYK7ytrqxby9x5hnMbR392ozFV2i4Woaz0pdAxq/ZQST1n3D9yZ/nmGGA32zRDpFB/sO1wutu42zW3zSaQPqxa9SvcDVJYf1Yih5k5WgWfWCd3QJ//uWepH37RHaDknMN9cL9BV51q+98p8y5ZNh2kly3vGC9Yd3sGD94d0jbBNOWr0QO+WpF79K5ay9YSVrvbgKcuXEoPZWlyw7TTWdJUWPxi/yuE5+A/z7H1L7eN7BPOD6M6tOXiPMwn/LUie1XbK7eSONrU7y6ZMHEcO0Xbscw+4o9pI6gN/oxnfjm7S06SU/I4Pjn2gVHMutDHp3KiOT8sZZ3oWBuwT4fdq2HdnaicmscQF36vyQ4sJh4OPvdT+h6MTdEGvE/yTo0fhFXpn4v2OJCzgd6c4voslJgqOAaZFwov4y8f+2JS7IM2g3jPvsQ0cV/iOK3apkN3zWs71Cm732Z7DXdzPGBfy+jklLm17yE2lxAf2d44JWpsift0zFZtrJtidJ1mFFFtr8EMnCesxvMsHnRK4xwzC99mn3VjsMpR5ImYsfcVoCOvL/cXqjAvmQv0u7wDlu9aJxozfuJb3hMB70DpF8k6SMVz3oH/XjTqvfGSThMOxEncZe66+3281Ovb+15j4cjIfxnusftTtbGR+PelEU1YfhaCf9xo+/R+M6nHp32IeYxL4yYMkS15cV/jJhNKkK9gvoWZvuBYe6S4puz3aNbFhtedun8C9b8ob5lmfXFD2lvcl35h2Rcq9CWH2Vw6JiV60c1iw2ryk09OtZ5b2s6NFklRzKKlN+UHbWWGNSN/0b5ksNviGysY12WM6T74Rpc+ZCq5BuueakzX8I7rw7M9E/+HsQWHdXiYZleYBo+4DGJ0AxX+ybWh3Ae+xP+PwiYcDnSjP+BoFuZ9ajYdbajTLlZymYzs+SRU9Z0bOmPLfb/GiYucxd6MH8LJOeZYd60BfF91aCaV902S/xHC8ikb/iR36D22C0lbHnv9K4Wmg49sRnV4CO/P8JawH/RnHcU5va4jiEaW1GuSENbc71EGM0151VoKFPctLit9gi785VrDOSp9Vguhz+G8phmeZ5uN3ppr/D3aXJWqXYZZbvVICO/D+zzPPIM0GQbTywqvBjvoW/GkzHDXnWs736awpWSUI7QLqRhnOC7LcHgcZ+WwUax+ka0NAmnDSfFjvlWZMR3+S4IzrYd/YT3p3imdaf5H5EN/0d7i4lWpsaEN5Z/WtOmn0Fd963SaGNuLyxveW2FPsg3fTvDjaIdjKS6BIbLQR6mWj5DpT8cP9FfktsKSlyysT7JMVHHmt1s+V9x8TzLFp5lJR8auUoNuIxk60/7Nn/M28zF/2VYNoHfYy1tX65Ns7QxkHyrNbHLdG1Nm9UVvRosoS2Eky3bV039oizzMN48o36/fqG73kYzTds8zB5fWPe2hzOD4+XguD+2qM82/m1+FcNpsub69cC4ZlVVrVgdiz1Pd+ojd85/7NiCCfN5nIv73Z+rc28n7k4tHc3/RvuMj3ANivz/PCXpc3i+uWizXIpyzb/taI85zKWZvUF0V8JvPpmZLOrNq+oxfsy2VxrC0pEQz1Z5/fnVRb7Dpajj/lBxB4E7mOkrc5o+dbi/6y55p3ahllz7qib2w1tXVD0aeMtlzYT/NLHmTV3L/p5Du0WjQs9zf2q48L9ZCNPMa+pzc9L0vqI7FdoE/ZHnstGGs6p8RFwTFofSGxhdP80wzyI5oMlomnxR5sb5LVXrV2oBdN1bplotnkXboe66d9wdynS1oP2Kj6WKN9BYI/lWfpBWjna4hzmbVY/16ZDZGrzkra+esmi3+F4f2ruje1gyxv319hPlmY8X1byPWtdlO2kYdPqKMtdsORjp2e1OKX5jI99V636IOk1kk44GCWtXrO11/u+kmG/vQWi1xkOmsNGMsiz70uLk7z3Zx/hNElrO4PAfVyZ7KUEPYhH9JeJ//t7szamtvEVspGntevJutx+sBHHXq0d8jQPHpUJz9/Amc4/S681n+JYr/U9hKb1PapBMLPvIXk+4LkMpJ+Ca6OI9QDQkf8vUrvstKcby9CkpU0v+Ym1Pd24jlkGvZivINjON/Jzu7+m8GPZSP5qxK+1Idr4GW3O4yZcR9T4eY1J+P8KykjOVmj9xFXCrq1vav1E7l9qe7mM2r+nmOYprrR5DIBJGwOUiKatx7MvoQ20NfG8YwexRd6xg4s4xLHGV1vzixwXxKa2uOCyTvK4Dv1RbI110ke/Lk56rUGvFUWdOBrFUbJTv27ytufNbTr6ikn70t/SV2B+kVcm/n+BtvxHVL/Kij7D8hMLX2nG3y9kKPeWNu+9t7I5zb+4Oc0vuiub0xiFtgo09GOTDqS/0V4oS3CUif/fob9j0n54Rp6vKfr3k/57cCv3eF5yVeFfVfi/2EuTYpzs2wLdrue7v9BJ8vEeY/sJ1CttvcpXH9Z3n933nKM2n7wf7Po/tC8Lx0/aWB33iyL/2r5tmT+jvr3L+TitLeb21tPe2pj7MwHkR3Sv+tGdec1K9FcCr32PyZqVtv9Sm+fzPO6Kbf2GioLHfJ3jYDBdZohPZGltvea/aGu2Q5b1LHye+xtYxrb5Z+4XafPPWh8G9xhrdYzn4HBfuBYn9hP/fsUWtrUZkX8I4kqSXmt9bo4rtj3A2phDaNqYQ3z3ID3XTX+Hu0sT363uYNODZCPhP5LaRdtPLc8Egb0+MAbk1/YYi72w310le1X92Gsyx1LbwV5VspfwP2exl5b/FYu9agp/1WIvtCW/M61Kv9G28txe+eJOtmVfFP7jim21cSrOiZq0tOklP4k2TsU2ogx6Z9UX5M9S/lp9qRE/lrcW43neC/WuEQ1jM49vMcZLbMNYmrV/+P8+CCe3hWwBAA==","debug_symbols":"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","brillig_names":["process_log"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"11091894166229312484":{"error_kind":"fmtstring","length":20,"item_types":[]},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"get_counter","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"12099279057757775880":{"error_kind":"string","string":"DST_LEN too large for offset"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_counter"]},{"name":"increment","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3151558035338938026":{"error_kind":"fmtstring","length":75,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["debug_log_oracle_wrapper","random","decompose_hint","notify_created_note_oracle_wrapper","debug_log_oracle_wrapper","get_random_bytes","field_less_than","lte_hint","build_msg_block","attach_len_to_msg_block","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","directive_invert","directive_to_radix","directive_integer_quotient"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["initializer","private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"args_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_logs","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"contract_class_logs_hashes","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2709101749560550278":{"error_kind":"string","string":"Cannot serialize point at infinity as bytes."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3151558035338938026":{"error_kind":"fmtstring","length":75,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","random","notify_created_note_oracle_wrapper","debug_log_oracle_wrapper","get_random_bytes","field_less_than","build_msg_block","attach_len_to_msg_block","get_app_tag_as_sender","increment_app_tagging_secret_index_as_sender_wrapper","notify_created_nullifier_oracle_wrapper","directive_integer_quotient","directive_invert","directive_to_radix"]},{"name":"sync_notes","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VTvQ6CMBBu+YmCMqiJbia+QREMjCbuvkMDMuqAixuPLjXX9FKbMLQ18Uuaa+Hy/ZSDEgUKNSIWkCQHqAnUAL0Px3WGM7NDnmi6LvlrVhaJIZ9D/x9+6sm/gOT3dP9sBjyXQfHjLFJ3Pq4UzYSvzPKb+cy8mci5+kHOEcdM08aghmehoYci3zvYZ4Y+iQVR/3Q0uM9V1YxJvRD4Y/LtHevHWv8WzqnmX9TIwmdX8bwreMdPvG3Lhq81foEA3dM/z8Ie9lOzgDMuiZqN/nVvro/nrScTECRvfuFT84YGAAA=","debug_symbols":"nZJBCoMwEEXvMmsXmdio9SpSJGqUQEgkxkIR794o0triJtkM+eG/v3oLdKKZh1rq3kxQVgso03InjfZpWRNorFRKDvX5G8h2EPf+NHK9xclx66BkNAGhOygz4uleKuGfdH0kgDSwnwb2b4F9Ftanl/tISJEfCBLE24fClO0Yi8OyOCyPw4ooLMVrDPPsi93ZL7b6+ORW8kaJQ7J+1u3JOfcaxZ9+ozWt6GYrNhFPDvpbYZ5Q6mf99Bs=","brillig_names":["sync_notes"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Counter::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::initialize_parameters","fields":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"Counter::increment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Counter::increment_parameters","fields":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Counter"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"counters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"21":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"52":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"62":{"source":"// docs:start:setup\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Counter {\n    \n    use aztec::macros::{functions::{initializer, private}, storage::storage};\n    use aztec::prelude::{AztecAddress, Map};\n    use easy_private_state::EasyPrivateUint;\n    use value_note::{balance_utils, value_note::ValueNote};\n    \n    #[storage]\n    struct Storage<Context> {\n        counters: Map<AztecAddress, EasyPrivateUint<Context>, Context>,\n    }\n    \n    #[initializer]\n    #[private]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner, context.msg_sender());\n    }\n    \n    #[private]\n    fn increment(owner: AztecAddress, sender: AztecAddress) {\n        unsafe {\n            dep::aztec::oracle::debug_log::debug_log_format(\n                \"Incrementing counter for owner {0}\",\n                [owner.to_field()],\n            );\n        }\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner, sender);\n    }\n\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n}","path":"/Users/seppi/repos/aztec-private-counter/contracts/counter/src/main.nr"},"70":{"source":"use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"73":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"76":{"source":"use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        /// Safety:   Unconstrained logs have both their content and encryption unconstrained - it could occur that\n        /// the recipient is unable to decrypt the payload.\n        ///   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can\n        /// have more than one log and removes all of the matching ones, so all a malicious sender could do is\n        /// either: cause for the log to be deleted when it shouldn't have (which is fine - they can already make\n        /// the content be whatever), or cause for the log to not be deleted when it should have (which is also fine\n        /// - it'll be a log for a note that doesn't exist).\n        ///   It's important here that we do not return the log from this function to the app, otherwise it could\n        /// try to do stuff with it and then that might be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"77":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key)\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"79":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, hash::poseidon2_hash,\n    point::Point, public_keys::AddressPoint, scalar::Scalar, utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    /// Safety: We assume that the sender wants for the recipient to find the tagged note, and therefore that they\n    /// will cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to\n    /// find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\n// We return [Field; 1 + (M + 30) / 31], where M is the byte length of output of encryption because\n// each field (apart from the tag) contains 31 bytes so the length in fields is computed as ceil(setup_log_byte_length / 31)\n// --> we achieve rounding by adding 30 and then dividing without remainder, then add one for the 32 byte tag\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; 1 + (M + 30) / 31] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M] = compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    /// Safety: We assume that the sender wants for the recipient to find the tagged note, and therefore that they\n    /// will cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to\n    /// find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    let siloed_tag = poseidon2_hash([contract_address.to_field(), tag]);\n\n    array_concat([siloed_tag], bytes_to_fields(encrypted))\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; HEADER_SIZE] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    // Nargo seems to struggle with realizing that `offset` is a constant at this point.\n    // We then redefine it in terms of the assertion above to give nargo a hint.\n    let offset = M - incoming_body_ciphertext.len();\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    /// Safety: A malicious sender could reveal the whole contents of the encrypted log so trusting it to set\n    /// a random padding in plaintext is fine.\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    /// Safety: We use the randomness to preserve the privacy of both the sender and recipient via encryption, so\n    /// a malicious sender could use non-random values to reveal the plaintext. But they already know it themselves\n    /// anyway, and so the recipient already trusts them to not disclose this information. We can therefore assume\n    /// that the sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8; P + 16 - P % 16] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"83":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"95":{"source":"use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/10537): Replace use of sha256\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr"},"99":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"108":{"source":"use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |serialized_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(serialized_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::deserialize_content,\n///             note_header,\n///             true,\n///             serialized_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, serialized_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                serialized_note_content,\n                header,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        serialized_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let serialized_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, serialized_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr"},"109":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"111":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"113":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    /// Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    /// is check that the metadata is correct, and that the note exists.\n    let note = unsafe { get_note_internal(storage_slot) };\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    /// Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"118":{"source":"use crate::note::constants::MAX_NOTES_PER_PAGE;\nuse crate::note::note_getter_options::{NoteStatus, PropertySelector, Select, Sort};\nuse crate::note::note_interface::NoteInterface;\nuse dep::protocol_types::traits::ToField;\nuse std::option::Option;\n\n// docs:start:NoteViewerOptions\npub struct NoteViewerOptions<Note, let N: u32> {\n    pub selects: BoundedVec<Option<Select>, N>,\n    pub sorts: BoundedVec<Option<Sort>, N>,\n    pub limit: u32,\n    pub offset: u32,\n    pub status: u8,\n}\n// docs:end:NoteViewerOptions\n\nimpl<Note, let N: u32> NoteViewerOptions<Note, N> {\n    pub fn new() -> NoteViewerOptions<Note, N>\n    where\n        Note: NoteInterface<N>,\n    {\n        NoteViewerOptions {\n            selects: BoundedVec::new(),\n            sorts: BoundedVec::new(),\n            limit: MAX_NOTES_PER_PAGE as u32,\n            offset: 0,\n            status: NoteStatus.ACTIVE,\n        }\n    }\n\n    // This method adds a `Select` criterion to the options.\n    // It takes a field_index indicating which field to select,\n    // a value representing the specific value to match in that field, and\n    // a comparator (For possible values of comparators, please see the Comparator enum from note_getter_options)\n    pub fn select<T>(\n        &mut self,\n        property_selector: PropertySelector,\n        comparator: u8,\n        value: T,\n    ) -> Self\n    where\n        T: ToField,\n    {\n        self.selects.push(Option::some(Select::new(property_selector, comparator, value.to_field())));\n        *self\n    }\n\n    pub fn sort(&mut self, property_selector: PropertySelector, order: u8) -> Self {\n        self.sorts.push(Option::some(Sort::new(property_selector, order)));\n        *self\n    }\n\n    pub fn set_limit(&mut self, limit: u32) -> Self {\n        assert(limit <= MAX_NOTES_PER_PAGE as u32);\n        // By requesting that the limit is a constant, we guarantee that it will be possible to loop over it, reducing\n        // gate counts when a limit has been set.\n        if !dep::std::runtime::is_unconstrained() {\n            assert_constant(limit);\n        }\n        self.limit = limit;\n        *self\n    }\n\n    pub fn set_offset(&mut self, offset: u32) -> Self {\n        self.offset = offset;\n        *self\n    }\n\n    // This method sets the status value, which determines whether to retrieve active or nullified notes.\n    pub fn set_status(&mut self, status: u8) -> Self {\n        self.status = status;\n        *self\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/note_viewer_options.nr"},"119":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"123":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"125":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"130":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"131":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"134":{"source":"use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr"},"135":{"source":"use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"137":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"141":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"146":{"source":"use crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateSet<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // TODO: This function is still around because of a stale blacklist token. It should most likely be nuked. If you\n    // need this functionality use partial notes instead.\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"},"169":{"source":"/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"170":{"source":"use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"174":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"227":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"234":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"237":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"239":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"244":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, FromField, Hash, Serialize, ToField},\n};\n\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"250":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"251":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_contract_class_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_contract_class_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"252":{"source":"use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr"},"267":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"268":{"source":"use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"277":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"280":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"314":{"source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr"},"322":{"source":"// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n","path":"/Users/seppi/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr"},"326":{"source":"use dep::aztec::{\n    context::PrivateContext, encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n    note::note_getter_options::NoteGetterOptions, protocol_types::address::AztecAddress,\n    state_vars::PrivateSet,\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\npub struct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, sender: AztecAddress) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(encode_and_encrypt_note(self.context, owner, sender));\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, sender: AztecAddress) {\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note).emit(encode_and_encrypt_note(self.context, owner, sender));\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr"},"328":{"source":"use crate::value_note::ValueNote;\nuse dep::aztec::{\n    context::UnconstrainedContext, note::note_viewer_options::NoteViewerOptions,\n    state_vars::PrivateSet,\n};\n\npub unconstrained fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\npub unconstrained fn get_balance_with_offset(\n    set: PrivateSet<ValueNote, UnconstrainedContext>,\n    offset: u32,\n) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/value-note/src/balance_utils.nr"},"332":{"source":"use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\npub(crate) global VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/seppi/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.72.1/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}